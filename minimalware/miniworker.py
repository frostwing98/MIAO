import re
import requests
import time
import json
import urllib
import string
from subprocess import check_call,CalledProcessError      
import hashlib

#import db
import random
import os
import subprocess
import time
import re
import ntpath
from multiprocessing.managers import BaseManager
import time

datapath="/storage/miniapp/wechat/packages/"
targetdir="./output/"

 

class detectedresult:
    appid=""
    path=""
    name=""
    
    similarityhit=False
    def __init__(self,appid,path):
        self.appid=appid
        self.path=path  
        self.similarityhit=False
    
    def getresult(self):
        return json.dumps(self.__dict__)
        # return "{}, name={}, path={}, hiddenapis={}, boxgame={}, locationbypass={}, suanming={}, bypass={}, shareabuse={}, fakeapp={}, fakechat={}, redpocket={}, timebased={}, collusion={}, eval5={}, vm={}, hotupdate={}, pyramidselling={}, locids={}, userinfo={}, crossinfo={}, apis={}".format(self.appid, self.name, self.path, self.hiddenapis, self.boxgame, self.locationbypass, self.suanming, self.bypass, self.shareabuse, self.fakeapp, self.fakechat, self.redpocket, self.timebased, self.collusion, self.eval5, self.vm, self.hotupdate, self.pyramidselling, self.locids, self.userinfo, self.crossinfo, self.apis)

publicapis=[]
 

# def loadnameDB():
#     global names
#     namefile=open("names.csv","r")
#     for line in namefile:
#         line=line.strip()
#         objs=line.split()
#         names[objs[0]]=objs[2]
#     print("NameDB loaded:", len(names))
 
def get_first_page(path):
    jsonfile=open(path+"/app.json","r")
    print(jsonfile)
    index=0
    fp=""
    try:
      for l in jsonfile:
        index=index+1
        if(index<3):
            continue
        print(l)
        fp=l.strip().split('"')[1]+".wxml"
 
        return fp
    except:
      pass
    return "None"

 



def loadpublicapis():
    # global publicapis
    # apis=open("publicAPIs.csv","r")
    # for api in apis:
    #     publicapis.append(api.strip())
        
    # appendlist=['wx.rprm', 'wx.storeId', 'wx.min', 'wx.vue', 'wx.bncxw','wx.qy', 'wx.getStyle', 'wx.length', 'wx.key', 'wx.test', 'wx.getSavedFileInfo','wx.bncxw', 'wx.bjcxdf', 'wx.requestpayment', 'wx.createContext', 'wx.drawCanvas', 'wx.hloop']    
    # publicapis.extend(appendlist)
    # print("public API loaded:", len(publicapis))
    print("not loading public APIs")
  
def scan(appid,name, path):
    global publicapis
 
 
    res = detectedresult(appid,path)
    hashlists={}
    res.name=name
    pubapis=[]
    # firstpage = get_first_page(path)
 
    
 
 
    for root, dirs, files in os.walk(path):
        # for file in files:
             
        for file in files:
                    
                if not (file.endswith(".js") or file.endswith(".wxml")):
                    continue

                jsfile=open(os.path.join(root, file))
                p=re.compile("wx\.[A-Za-z]+")
                startflag=False
                reportflag=False
                redpocketflag=False
                paymentflag=False
                transferflag=False
                lines=""
                for line in jsfile:
                    lines+=line
                
                    # fake report
                    if "投诉对象" in line or "请输入投诉内容" in line or "证据截图" in line:
                        reportflag=True
                    if "单个金额" in line or "红包封面" in line or  "塞钱进红包" in line or  "恭喜发财" in line:
                        redpocketflag=True
                    if "转账金额" in line or "添加转账说明" in line or "转账" in line:
                        transferflag=True
                    if "支付密码" in line or "支付方式" in line: 
                        paymentflag=True
                digeststr=hashlib.md5(lines.encode()).hexdigest()
                if paymentflag or transferflag or redpocketflag or reportflag:
                    if digeststr not in hashlists:
                        hashlists[digeststr]=[]
                    res.similarityhit=True
                    hashlists[digeststr].append({
                        'path':os.path.join(root, file),
                        'report':reportflag,
                        'transfer':transferflag,
                        'payment':paymentflag,
                        'redpocket': redpocketflag
                    })
                    
                    
                    
                        
    
    resobj=json.loads(res.getresult())
    resobj['hashlists']=hashlists
    resobj=json.dumps(resobj)
    return resobj
 


def unpack_miniapp(appid):
    apppath=datapath+'wx'+appid[0:6]+'/'+appid[6:8]+"/"+appid+'.wxapkg'
    targetpath=targetdir+appid
    print(apppath,targetpath)
    print("./decrypt.sh "+appid)
    try:
       check_call(["./decrypt.sh", appid])
    except CalledProcessError as e:
       print(e)
   
    return 
    

def remove_miniapp(appid):
    apppath=targetdir+appid
    os.system("./clean.sh "+apppath)
    
def scan_miniapp(appid,name):
    unpack_miniapp(appid)
    print('unpacked!')
    res=scan(appid, name, targetdir+appid)
    print('scanned!')
    remove_miniapp(appid)
    
    return res





  
if __name__ == '__main__':

    print("Miniapp Scanner Slave")


    class QueueManager(BaseManager):
        pass

    QueueManager.register("get_task_queue")
    QueueManager.register("get_result_queue")
    server_addr = '127.0.0.1'
    print('Connect to server %s...' % server_addr)

    m = QueueManager(address=(server_addr, 8989), authkey=b'abc')
    m.connect()
    task = m.get_task_queue()
    result = m.get_result_queue()
    loadpublicapis()
 
    while True:
        try:
            scanstr = task.get(timeout=10)
            print(scanstr)
            #print(res)
            start_time = time.time()
            appid=scanstr
            # name=scanstr[1]
 
            res = scan_miniapp(appid,'')
            end_time = time.time()
            
            # writeres(res.getresult())
            # print(res.getresult())
            print(res)
            
            result.put(res)
        except BrokenPipeError:
            print("finished")
            break
        except Exception as e:
            print(e)
            continue
